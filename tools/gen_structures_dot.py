#!/usr/bin/env python3
# Generated by GPT 5.2.

# Instructions:
#
# Run from the kosmos base directory:
# python3 tools/gen_structures_dot.py > docs/kosmos-structures.dot
# dot -Tsvg docs/kosmos-structures.dot -o docs/kosmos-structures.svg
# dot -Tpng docs/kosmos-structures.dot -o docs/kosmos-structures.png

from __future__ import annotations

import os
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable


DECL_START_RE = re.compile(r"^\s*(data\s+class|class|interface)\s+")
NAME_RE = re.compile(r"^\s*(?:data\s+class|class|interface)\s+([A-Za-z_]\w*)")


@dataclass(frozen=True)
class Decl:
    kind: str          # "interface" | "class" | "data class"
    name: str
    supers: tuple[str, ...]


def strip_generics(type_ref: str) -> str:
    s = type_ref.strip()
    if s.endswith("?"):
        s = s[:-1]
    s = s.split("<", 1)[0]
    s = s.split(" ", 1)[0]
    return s.strip()


def is_decl_start(line: str) -> bool:
    return DECL_START_RE.match(line) is not None


def parse_decl_header(lines: list[str], start: int) -> tuple[str, int]:
    """
    Return a single-line header (concatenated) and the index of the last line consumed.
    We keep concatenating until we hit '{' or '=' or 'where' in any line.
    """
    parts: list[str] = []
    i = start
    while i < len(lines):
        line = lines[i].strip()

        # skip full-line comments
        if line.startswith("//"):
            i += 1
            continue

        parts.append(line)

        if "{" in line or "=" in line or " where " in f" {line} ":
            break

        i += 1

    header = " ".join(parts)
    return header, i


def parse_decl_from_header(header: str) -> Decl | None:
    header = header.strip()

    m_kind = DECL_START_RE.match(header)
    if not m_kind:
        return None

    kind = m_kind.group(1).strip()
    m_name = NAME_RE.match(header)
    if not m_name:
        return None

    name = m_name.group(1)

    # Extract supertypes: after ":" up to "{" or "where" or "="
    supers_part = ""
    if ":" in header:
        supers_part = header.split(":", 1)[1]
        supers_part = supers_part.split("{", 1)[0]
        supers_part = supers_part.split(" where ", 1)[0]
        supers_part = supers_part.split("where", 1)[0]
        supers_part = supers_part.split("=", 1)[0]
        supers_part = supers_part.strip()

    supers: list[str] = []
    if supers_part:
        for raw in supers_part.split(","):
            t = strip_generics(raw)
            if t:
                supers.append(t)

    return Decl(kind=kind, name=name, supers=tuple(supers))


def collect_decls(root: Path) -> list[Decl]:
    decls: list[Decl] = []

    for path in root.rglob("*.kt"):
        try:
            lines = path.read_text(encoding="utf-8").splitlines()
        except UnicodeDecodeError:
            # fallback in case of odd encodings
            lines = path.read_text(errors="replace").splitlines()

        i = 0
        while i < len(lines):
            if not is_decl_start(lines[i]):
                i += 1
                continue

            header, end_i = parse_decl_header(lines, i)
            decl = parse_decl_from_header(header)
            if decl:
                decls.append(decl)

            i = end_i + 1

    return decls


def node_attrs(kind: str) -> str:
    if kind == "interface":
        return "shape=ellipse"
    if kind == "data class":
        return "shape=box3d"
    return "shape=box"


def emit_dot(decls: list[Decl]) -> str:
    names = {d.name for d in decls}

    edges: set[tuple[str, str]] = set()
    for d in decls:
        for s in d.supers:
            if s in names:
                # parent -> child
                edges.add((s, d.name))

    node_lines = []
    for d in sorted({d.name: d for d in decls}.values(), key=lambda x: x.name):
        node_lines.append(f'  "{d.name}" [{node_attrs(d.kind)}];')

    edge_lines = []
    for parent, child in sorted(edges, key=lambda t: (t[0], t[1])):
        edge_lines.append(f'  "{parent}" -> "{child}";')

    return "\n".join(
        [
            "digraph KosmosStructures {",
            "  rankdir=LR;",
            '  node [fontname="Helvetica"];',
            '  edge [fontname="Helvetica"];',
            "",
            *node_lines,
            "",
            *edge_lines,
            "}",
            "",
        ]
    )


def main() -> None:
    default_root = Path("kosmos-core/src/main/kotlin/org/vorpal/kosmos/algebra/structures")
    root = Path(os.environ.get("KOSMOS_STRUCTURES_ROOT", str(default_root)))

    if not root.exists():
        raise SystemExit(f"Root does not exist: {root}")

    decls = collect_decls(root)
    print(emit_dot(decls), end="")


if __name__ == "__main__":
    main()